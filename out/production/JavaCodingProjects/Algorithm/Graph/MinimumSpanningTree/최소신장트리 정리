알고리즘
1. 신장 트리(Spanning Tree)
원래의 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족하는 그래프
신장 트리의 조건
    본래의 그래프의 모든 노드를 포함해야 함
    모든 노드가 서로 연결
    트리의 속성을 만족시킴(사이클이 존재하지 않음)

2. 최소 신장 트리(Minimum Spanning Tree, mst)
대표적인 최소 신장 트리 알고리즘
    Kruskal's algorithm(크루스칼 알고리즘)
    Prim's algorithm(프림 알고리즘)

------------------------------------------------

※ 크루스칼 알고리즘
모든 정점을 독립적인 집합으로 만든다.
모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교한다.
두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결한다.
(최소 신장 트리는 사이클이 없으므로, 사이클이 생기지 않도록 하는 것임)
탐욕 알고리즘을 기초로 하고 있음(당장 눈 앞의 최소 비용을 선택해서, 결과적으로 최적의 솔루션을 찾음)

가중치가 낮은 순서대로 간선을 연결하면서 사이클이 생기지 않고
모든 노드가 간선으로 연결되게 하기

※ Union-Find 알고리즘 (크루스칼 알고리즘을 해결하기 위한 것)
Disjoint Set을 표현할 때 사용하는 알고리즘으로 트리 구조를 활용하는 알고리즘
간단하게, 노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때(합칠 때) 사용
Disjoint Set이란?
    서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조
    공통 원소가 없는(서로소) 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 자료구조를 의미함
    Disjoint Set = 서로소 집합 자료구조

1) 초기화
n개의 원소가 개별 집합으로 이뤄지도록 초기화
2) Union
두 개별 집합을 하나의 집합으로 합침, 두 트리플 하나의 트리로 만듬
3) Find
여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지
판별하기 위해, 각 그룹의 최상단 원소 (즉, 루트노드)를 확인

※ union-by-rank 기법
※ path compression 기법
두가지 기법은 사이클을 체크하기 위해서 사용됨 (시간복잡도가 결국 상수값에 가까움.)

※ 크루스칼 시간 복잡도
초기화 : O(V)
정렬 : O(ElogE)
최소신장트리를 구성하는 edge를 선택하기 위해서 반복문 : O(E)
O(V) + O(ElogE) + O(E) = O(ElogE)

------------------------------------------------

※ 프림 알고리즘(Prim's algorithm)
시작 정점을 선택한 후, 정점에 인접한 간선중 최소 간선으로 연결된 정점을 선택하고, 해당 정점에서
다시 최소 간선으로 연결된 정점을 선택하는 방식으로 최소 신장 트리를 확장해가는 방식

※ 크루스칼과 프림 비교
둘다 탐욕 알고리즘을 기초로 하고 있음(당장 눈 앞의 최소 비용을 선택해서,
결과적으로 최적의 솔루션을 찾음

크루스칼은 가장 가중치가 작은 간선부터 선택하면서 MST를 구함

프림은 특정 정점에서 시작해서 해당 정점에 연결된 가장 가중치가 작은 간선 선택
간선으로 연결된 정점들에 연결된 간선 중에서 가장 가중치가 작은 간선을 택하는 방식으로
MST를 구함

※ 프림 시간복잡도
최악의 경우, while 구문에서 모든 간선에 대해 반복하고,
최소 힙 구조를 사용하므로 O(ElogE) 시간 복잡도를 가진다.

------------------------------------------------

※ 참고 : 개선된 프림 알고리즘
간선이 아닌 노드를 중심으로 우선순위 큐를 적용하는 방식

※ 참고 : 개선된 프림 알고리즘의 시간 복잡도
최초 key 생성 시간 복잡도 : O(V)
while구문과 keys.poll 시간 복잡도 : O(VlogV)
for 구문 총 시간 복잡도 : O(ElogV)

O(ElogV) = O(V + VlogV + ElogV)
