※ 자료구조
대량의 데이터를 효율적으로 관리할 수 있는 데이터의 구조
코드상에서 효율적으로 데이터를 처리하기 위해, 데이터 특성에 따라,
체계적으로 데이터를 구조화해야함
(어떤 데이터 구조를 사용하느냐에 따라, 코드 효율이 달라짐)

배열, 스택, 큐, 링크드 리스트, 해쉬 테이블, 힙

※ 알고리즘
어떤 문제를 풀기 위한 절차/방법
어떤 문제에 대해, 특정한 '입력'을 넣으면, 원하는 '출력'을 얻을 수 있도록 
만드는 프로그래밍

※ 자료구조와 알고리즘이 중요한 이유
어떤 자료구조와 알고리즘을 쓰느냐에 따라, 성능이 천지차
결국 프로그래밍을 잘 할 수 있는 기술과 역량을 익히고, 검증할 수 있음

---------------------------------------------------

※ JRE(Java Runtime Environment)
컴파일된 자바 프로그램을 실행시킬 수 있는 환경을 제공해주는 프로그램

※ JDK(Java Development Kit)
자바 프로그래밍 작성시 필요한 컴파일러 및 패키지 등을 포함
JDK = JRE + @


---------------------------------------------------

마크다운으로 문서만드는 연습하기

---------------------------------------------------

※ 알고리즘 복잡도 표현 방법
알고리즘 복잡도 계산이 필요한 이유
다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산함.

※ 알고리즘 복잡도 계산 항목
1. 시간 복잡도 : 알고리즘 실행속도 ★
2. 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

※ 알고리즘 시간 복잡도 주요 요소
반복문이 지배한다.
입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배함

※ 알고리즘 성능 표기법
Big O(빅-오) 표기법 : O(N) ★
    알고리즘 최악의 실행 시간 표기
    가장 많이/일반적으로 사용함
    아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미

θ(세타) 표기법 : θ(N)
    세타 표기법은 알고리즘 평균 실행 시간을 표기

Ω(오메가) 표기법 : Ω(N)
    오메가 표기법은 알고리즘 최상의 실행 시간을 표기

※ 빅-오 표기법
만약 시간 복잡도 함수가 2n² + 3n이라면
가장 높은 차수는 2n²이고, 상수는 실제 큰 영향이 없으므로 표기는 O(n²)으로 한다.

O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(2ⁿ) < O(n!)
        log는 무엇(??)

O(1) :
if(n > 10) {
    System.out.println(n);
}

O(n) :
for(int num = 0; num < 3; num++) {
    for(int index = 0; index < n; index++) {
        System.out.println(index);
    }
}

O(n²) :
for(int i = 0; i < 3; i++) {
    for(int num = 0; num < n; num++) {
        for(int index = 0; index < n; index++) {
            System.out.println(index);
        }
    }
}

------------------------------------------------------------------

시간 복잡도
빅-오 표기법 예시

1번 방법 : O(n)
public class Main {
    public int sum(int n) {
        total += i;
        for(int i=1; i<=n; i++) {
            return total;
        }
    }

    public static void main(String[] args) {
        Main mainObject = new Main();
        mainObject.sum(10);
    }
}

2번 방법 : O(1)
public class Main {
    public int sum(int n) {
        return n*(n+1)/2;
    }

    public static void main(String[] args) {
        Main mainObject = new Main();
        mainObject.sum(10);
    }
}

------------------------------------------------------------------

공간 복잡도
빅-오 표기법 예시

고정 공간(알고리즘과 무관한 공간) : 코드 저장 공간, 단순 변수 및 상수
가변 공간(알고리즘 실행과 관련있는 공간) : 실행중 동적으로 필요한 공간

빅-오 표기법을 생각해볼 때, 고정 공간은 상수이므로 공간 복잡도는 가변 공간에 좌우됨.

1번 방법 : O(1) , n에 따라서 fac와 index는 한번만 쓰인다.
public class Factorial {
    public int factorialFunc(int n) {
        int fac = 1;
        for(int index = 2; index < n+1; index++) {
            fac = fac * index;
        }
        return fac;
    }

    public static void main(String[] args) {
        Factorial fObject = new Factorial();
        fObject.factorialFunc(5); // 120
    }
}


2번 방법 : O(n) , 재귀함수로 n이 여러번 호출되면서 fac와 index가 n번 쓰인다.
public class Factorial {
    public int factorialFunc(int n) {
         if(n > 1) {
            return n * factorialFunc(n - 1);
         } else {
            return 1;
         }
    }

    public static void main(String[] args) {
        Factorial fObject = new Factorial();
        fObject.factorialFunc(5); // 120
    }
}
------------------------------------------------------------------

리스트
https://visualgo.net/en/list
정렬
https://visualgo.net/en/sorting

------------------------------------------------------------------

동적계획법과분할정복

※ 동적계획법(DP)
입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제를 활용해서 더 큰 문제를 해결하는 방식으로
최종적으로 전체 문제를 해결하는 알고리즘
상향식 접근법으로 가장 최하위 해답을 구한 후, 이를 저장하고 결과를 이용해 상위 문제를 풀어가는 방식
Memorization기법 : 프로그램 실행시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행
속도를 빠르게 하는 기술
문제를 잘게 쪼갤 때, 부분 문제는 중복되어 재활용됨 (피보나치 수열)

※ 분할 정복
문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
하향식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식
(일반적으로 재귀함수로 구현)
문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음
(병합 정렬, 퀵 정렬)

※ 공통점과 차이점
공통점
    문제를 잘게 쪼개서, 가장 작은 단위로 분할
차이점
    동적 계획법
        부분 문제는 중복되어, 상위 문제 해결 시 재활용 됨
        Memorization기법 사용(부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)
    분할 정복
        부분 문제는 서로 중복되지 않음
        Memorization기법 사용 안함.